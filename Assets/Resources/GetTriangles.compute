#pragma kernel CSMain

struct Triangle
{
    float3 v0, v1, v2;
    float2 uv0, uv1, uv2;
};

AppendStructuredBuffer<Triangle> triangleBuffer;
StructuredBuffer<float3> vertexBuffer;
StructuredBuffer<float2> textureBuffer;
StructuredBuffer<int> indicesBuffer;
RWStructuredBuffer<float3> processVertices;
RWStructuredBuffer<float2> processTextures;
RWStructuredBuffer<bool> processBool;
RWStructuredBuffer<float3> temporaryVertices;
RWStructuredBuffer<float2> temporaryTextures;
RWStructuredBuffer<uint> argsBuffer;

float4 CamPosition;
float4 planes[6];

[numthreads(1, 1, 1)]
void CSMain(uint id : SV_DispatchThreadID)
{
    uint i30 = id * 3;
    uint i31 = id * 3 + 1;
    uint i32 = id * 3 + 2;
    
    uint ib0 = indicesBuffer[i30];
    uint ib1 = indicesBuffer[i31];
    uint ib2 = indicesBuffer[i32];

    uint baseIndex = id * 256;
    
    float3 edge1 = vertexBuffer[ib1] - vertexBuffer[ib0];
    float3 edge2 = vertexBuffer[ib2] - vertexBuffer[ib0];
    float3 normal = normalize(cross(edge1, edge2));
    float3 camDir = normalize(CamPosition.xyz - vertexBuffer[ib0]);
    float triangleDirection = dot(normal, camDir);

    if (triangleDirection < 0)
    {
        return;
    }
    
    uint processverticescount = 0;
    uint processtexturescount = 0;
    uint processboolcount = 0;
    
    processVertices[baseIndex + processverticescount] = vertexBuffer[ib0];
    processVertices[baseIndex + processverticescount + 1] = vertexBuffer[ib1];
    processVertices[baseIndex + processverticescount + 2] = vertexBuffer[ib2];
    processverticescount += 3;
    processTextures[baseIndex + processtexturescount] = textureBuffer[ib0];
    processTextures[baseIndex + processtexturescount + 1] = textureBuffer[ib1];
    processTextures[baseIndex + processtexturescount + 2] = textureBuffer[ib2];
    processtexturescount += 3;
    processBool[baseIndex + processboolcount] = true;
    processBool[baseIndex + processboolcount + 1] = true;
    processBool[baseIndex + processboolcount + 2] = true;
    processboolcount += 3;
    
    for (uint b = 0; b < 6; b++)
    {
        uint AddTriangles = 0;
        uint temporaryverticescount = 0;
        uint temporarytexturescount = 0;
    
        for (uint c = baseIndex; c < baseIndex + processverticescount; c += 3)
        {
            if (processBool[c] == false && processBool[c + 1] == false && processBool[c + 2] == false)
            {
                continue;
            }

            float3 v0 = processVertices[c];
            float3 v1 = processVertices[c + 1];
            float3 v2 = processVertices[c + 2];

            float2 uv0 = processTextures[c];
            float2 uv1 = processTextures[c + 1];
            float2 uv2 = processTextures[c + 2];
            
            float d0 = dot(planes[b].xyz, processVertices[c]) + (planes[b].w);
            float d1 = dot(planes[b].xyz, processVertices[c + 1]) + (planes[b].w);
            float d2 = dot(planes[b].xyz, processVertices[c + 2]) + (planes[b].w);
            
            bool b0 = d0 >= 0;
            bool b1 = d1 >= 0;
            bool b2 = d2 >= 0;

            if (b0 && b1 && b2)
            {
                continue;
            }
            else if ((b0 && !b1 && !b2) || (!b0 && b1 && !b2) || (!b0 && !b1 && b2))
            {
                float3 inV, outV1, outV2;
                float2 inUV, outUV1, outUV2;
                float inD, outD1, outD2;

                if (b0)
                {
                    inV = v0;
                    inUV = uv0;
                    inD = d0;
                    outV1 = v1;
                    outUV1 = uv1;
                    outD1 = d1;
                    outV2 = v2;
                    outUV2 = uv2;
                    outD2 = d2;
                }
                else if (b1)
                {
                    inV = v1;
                    inUV = uv1;
                    inD = d1;
                    outV1 = v2;
                    outUV1 = uv2;
                    outD1 = d2;
                    outV2 = v0;
                    outUV2 = uv0;
                    outD2 = d0;
                }
                else
                {
                    inV = v2;
                    inUV = uv2;
                    inD = d2;
                    outV1 = v0;
                    outUV1 = uv0;
                    outD1 = d0;
                    outV2 = v1;
                    outUV2 = uv1;
                    outD2 = d1;
                }

                float t1 = inD / (inD - outD1);
                float t2 = inD / (inD - outD2);

                temporaryVertices[baseIndex + temporaryverticescount] = inV;
                temporaryVertices[baseIndex + temporaryverticescount + 1] = lerp(inV, outV1, t1);
                temporaryVertices[baseIndex + temporaryverticescount + 2] = lerp(inV, outV2, t2);
                temporaryverticescount += 3;
                temporaryTextures[baseIndex + temporarytexturescount] = inUV;
                temporaryTextures[baseIndex + temporarytexturescount + 1] = lerp(inUV, outUV1, t1);
                temporaryTextures[baseIndex + temporarytexturescount + 2] = lerp(inUV, outUV2, t2);
                temporarytexturescount += 3;
                processBool[c] = false;
                processBool[c + 1] = false;
                processBool[c + 2] = false;

                AddTriangles += 1;
            }
            else if ((!b0 && b1 && b2) || (b0 && !b1 && b2) || (b0 && b1 && !b2))
            {
                float3 inV1, inV2, outV;
                float2 inUV1, inUV2, outUV;
                float inD1, inD2, outD;

                if (!b0)
                {
                    outV = v0;
                    outUV = uv0;
                    outD = d0;
                    inV1 = v1;
                    inUV1 = uv1;
                    inD1 = d1;
                    inV2 = v2;
                    inUV2 = uv2;
                    inD2 = d2;
                }
                else if (!b1)
                {
                    outV = v1;
                    outUV = uv1;
                    outD = d1;
                    inV1 = v2;
                    inUV1 = uv2;
                    inD1 = d2;
                    inV2 = v0;
                    inUV2 = uv0;
                    inD2 = d0;
                }
                else
                {
                    outV = v2;
                    outUV = uv2;
                    outD = d2;
                    inV1 = v0;
                    inUV1 = uv0;
                    inD1 = d0;
                    inV2 = v1;
                    inUV2 = uv1;
                    inD2 = d1;
                }

                float t1 = inD1 / (inD1 - outD);
                float t2 = inD2 / (inD2 - outD);

                float3 vA = lerp(inV1, outV, t1);
                float3 vB = lerp(inV2, outV, t2);

                float2 uvA = lerp(inUV1, outUV, t1);
                float2 uvB = lerp(inUV2, outUV, t2);

                temporaryVertices[baseIndex + temporaryverticescount] = inV1;
                temporaryVertices[baseIndex + temporaryverticescount + 1] = inV2;
                temporaryVertices[baseIndex + temporaryverticescount + 2] = vA;
                temporaryverticescount += 3;
                temporaryTextures[baseIndex + temporarytexturescount] = inUV1;
                temporaryTextures[baseIndex + temporarytexturescount + 1] = inUV2;
                temporaryTextures[baseIndex + temporarytexturescount + 2] = uvA;
                temporarytexturescount += 3;
                temporaryVertices[baseIndex + temporaryverticescount] = vA;
                temporaryVertices[baseIndex + temporaryverticescount + 1] = inV2;
                temporaryVertices[baseIndex + temporaryverticescount + 2] = vB;
                temporaryverticescount += 3;
                temporaryTextures[baseIndex + temporarytexturescount] = uvA;
                temporaryTextures[baseIndex + temporarytexturescount + 1] = inUV2;
                temporaryTextures[baseIndex + temporarytexturescount + 2] = uvB;
                temporarytexturescount += 3;
                processBool[c] = false;
                processBool[c + 1] = false;
                processBool[c + 2] = false;

                AddTriangles += 2;
            }
            else
            {
                processBool[c] = false;
                processBool[c + 1] = false;
                processBool[c + 2] = false;
            }
        }
        if (AddTriangles > 0)
        {
            for (uint d = baseIndex; d < baseIndex + temporaryverticescount; d += 3)
            {
                processVertices[baseIndex + processverticescount] = temporaryVertices[d];
                processVertices[baseIndex + processverticescount + 1] = temporaryVertices[d + 1];
                processVertices[baseIndex + processverticescount + 2] = temporaryVertices[d + 2];
                processverticescount += 3;
                processTextures[baseIndex + processtexturescount] = temporaryTextures[d];
                processTextures[baseIndex + processtexturescount + 1] = temporaryTextures[d + 1];
                processTextures[baseIndex + processtexturescount + 2] = temporaryTextures[d + 2];
                processtexturescount += 3;
                processBool[baseIndex + processboolcount] = true;
                processBool[baseIndex + processboolcount + 1] = true;
                processBool[baseIndex + processboolcount + 2] = true;
                processboolcount += 3;
            }
        }
    }
    for (uint e = baseIndex; e < baseIndex + processboolcount; e += 3)
    {
        if (processBool[e] == true && processBool[e + 1] == true && processBool[e + 2] == true)
        {
            Triangle tri;

            tri.v0 = processVertices[e];
            tri.v1 = processVertices[e + 1];
            tri.v2 = processVertices[e + 2];
            tri.uv0 = processTextures[e];
            tri.uv1 = processTextures[e + 1];
            tri.uv2 = processTextures[e + 2];
    
            triangleBuffer.Append(tri);
            
            InterlockedAdd(argsBuffer[0], 3);
        }
    }
}
